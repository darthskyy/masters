# Enhancing Tokenization for Nguni Languages: BPEKnockout and Unigram Approaches

This repository contains research and implementation work focused on tokenizers for Nguni languages (Zulu, Xhosa, Ndebele, and Swati).
(if it has an asterisk, I'm currently working on it)

## Project Overview

The project aims to improve tokenization approaches for Nguni languages by:

1. Implementing and evaluating baseline tokenization methods, specifically BPE (Byte Pair Encoding) and Unigram tokenizers. *
2. Adapting the BPEKnockout methodology to Nguni language tokenization. *
3. Extending morphological information inclusion to Unigram tokenizers in my future work.
4. Evaluating the effectiveness of these tokenization methods in capturing the rich morphological structures of Nguni languages.

Other sub-aims include:
- Implementing a pipeline for tokenization and evaluation *
- Comparing the performance of BPE and Unigram tokenizers *
- Identifying morphologically significant subword units
- Developing language-specific tokenization strategies

## Current Work: BPEKnockout for Nguni Languages

The initial phase focuses on implementing and evaluating the BPEKnockout approach for Nguni languages. BPEKnockout is a method that allows for measuring the importance of specific tokens in a BPE vocabulary by systematically "knocking out" tokens and measuring their impact on model performance.

Key objectives:
- Adapt BPEKnockout for Zulu, Xhosa, Ndebele, and Swati
- Evaluate the effectiveness of different tokenization schemes
- Identify morphologically important subword units specific to these languages

## Future Work: Morphological Information in Unigram Tokenizers

The second phase will focus on extending our approach to Unigram tokenizers:
- Incorporate morphological information into the Unigram tokenization process
- Compare performance between BPE and Unigram approaches for Nguni languages
- Develop language-specific tokenization strategies that better capture the rich morphological structures of Nguni languages

## Repository Structure

(This section will be populated as the project develops)

## Requirements

(List of requirements and dependencies)

## Usage

(Instructions on how to use the code)

## References

(Relevant references and papers)